% Подготавлиеваем массивы, которые будут содержать сеточные значения искомой функции u в различные моменты времени 
u = zeros(1,N+1); % Первая компонента - число временных слоёв, вторая - число узлов по координате 
u_final = zeros(M_0+1,N_0 + 1); % Массив значений восстановленной функции u в узлах, совпадающих с исходной сеткой 

u(1,:) = u_initial(x); 

% Индекс отвечающий за выбор временных слоёв, 
% совпадающих с временными слоями базовой сетки 
m_basic = 1; 
% Выбираем на каждой сетке узлы, совпадающие с узлами исходной сетки 
% Сразу делаем это для первого (начального) временного слоя, 
% т.к. на всех сетках он является совпадающим 
for n = 1:(N_0 + 1) 
u_final(m_basic,n) = u(1,(n - 1)*r_x^(s - 1) + 1); 
end 
m_basic = m_basic + 1; 

% Ищем решение ОДУ по схеме Розенброка (CROS1) 
for m = 1:M 

% Непосредственно схема Розенброка (CROS1) 

% w ищем с помощью метода прогонги 

% Сначала подготавливаем массивы, которые будут содержать 
% коэффициенты на диагоналях соответствующей трёхдиагональной матрицы 
[a, b, c] = DiagonalsPreparation(u(1,2:N),t(m),(t(m + 1) - t(m)),x,epsilon,u_left,u_right,a_scheme); 

w = TridiagonalMatrixAlgorithm(a,b,c,f(u(1,2:N),(t(m + 1) + t(m))/2,x,epsilon,u_left,u_right)); 
u(1,2:N) = u(1,2:N) + (t(m + 1) - t(m))*real(w'); 

% Делаем проверку, не совпадает решение, 
% найденное на текущем временном слое (m + 1) (по слою m) 
% с очередным временным слоем базовой сетки 
if (m + 1) == (m_basic - 1)*r_t^(s - 1) + 1 

% Учитываем левое и правое граничные условия 
u(1,1) = u_left; 
u(1,N + 1) = u_right; 

% Выбираем на каждой сетке узлы, совпадающие с узлами исходной сетки 
for n = 1:(N_0 + 1) 
u_final(m_basic,n) = u(1,(n - 1)*r_x^(s - 1) + 1); 
end 

% Не забываем, что теперь очередной временной слой 
% базовой сетки имеет другой индекс 
m_basic = m_basic + 1; 

end 

m 

end

