program main

	implicit none
	
	real(8) :: epsilon
	real(8) :: x_left, x_right, T_calc, u_left, u_right
	integer :: i, j
	integer :: N, M
	real(8) :: h, tau
	real(8), allocatable :: x(:), t(:), u(:,:)
	real(8), allocatable :: f(:)
	double complex i_unit, a_11
	double complex, allocatable :: a(:), b(:), c(:), w(:)

	epsilon = 10**(-1.3d0)		! Задаём малый парамет \varepsilon
	
	x_left = 0.d0				! Задаём левую границу области по координате
	x_right = 1.d0				! Задаём правую границу области по координате

	N = 200						! Задаём число интервалов сетки по пространству N
	M = 300						! Задаём число интервалов сетки по времени M

	T_calc = 0.5d0				! Определяем время счёта
	
	allocate(x(0:N),t(0:M))	

	h = (x_right - x_left)/N	! Вычисляем величину шага по координате
	tau = (T_calc - 0.d0)/M     ! Вычисляем величину шага по времени
	
	do i = 0,N
		x(i) = x_left + h*i		! Формируем сетку по координате
	enddo		

	do j = 0,M
		t(j) = 0.d0 + tau*j		! Формируем сетку по времени
	enddo	

	u_left = -5.d0				! Задаём левое граничное условие        
	u_right = 2.d0				! Задаём правое гарничное условие

	i_unit = (0.0d0, 1.0d0) 
	! Параметр, отвечающий за свойства схемы:
	a_11 = (1.0d0+i_unit)/2.0d0	! CROS1 - схема Розенброка с комплексным коэффициентом (p_t = 2, L2-устойчивость, монотонность ЕСТЬ)
	!a_11 = (0.5d0,0.d0)				! KN - схема Крэнака-Николсона - она же "схема с полусуммой" (p_t = 2, A-устойчивость, монотонности НЕТ)
	!a_11 = (1.0d0,0.d0)			! DIRK1 - обратная схема Эйлера - она же "чисто неявная" (p_t = 1, L1-устойчивость, монотонности ЕСТЬ)
	!a_11 = (0.0d0,0.d0)					! ERK1 - схема Эйлера (p_t = 1, устойчивости НЕТ, монотонности НЕТ)

	! Подготавлиеваем массив, который будет содержать сеточные значения
	! функции в различные моменты времени (каждая строка будет соответствовать своему временному слою)
	allocate(u(0:M,0:N)) ! Первая компонента - число временных слоёв, вторая число узлов по координате

	! Выделяем место под массивы, которые будут содержать диагонали трёхдиагональной матрицы
	allocate(a(1:N-1),b(1:N-1),c(1:N-1))
	a = (0.d0,0.d0)
	b = (0.d0,0.d0)
	c = (0.d0,0.d0)
	
	! Выделяем место под вектор правой части, решаемой системы ОДУ
	allocate(f(1:N-1),w(1:N-1))

	! Задаём начальное условие
	do i = 0,N
		u(0,i) = ((x(i) + 1.d0) + (x(i) - 5.d0)*dexp(-3.d0*(x(i) - 0.5d0)/epsilon))/(1.d0 + dexp(-3.d0*(x(i) - 0.5d0)/epsilon)) 
	enddo
	
	! Ищем решение ОДУ в каждый следующий момент времени (t + tau) по
	! известному решению в текущй момент времени t
	do j = 0,(M-1)
    
		! Cхема Розенброка (CROS1)
    
		! w ищем с помощью метода прогонги
        
		! Сначала подготавливаем массивы, которые будут содержать
		! коэффициенты на диагоналях соответствующей трёхдиагональной матрицы
		call DiagonalsPreparation(a,b,c,N,u(j,:),t(j),(t(j + 1) - t(j)),x,epsilon,u_left,u_right,a_11)
        
        ! Вычисляем вектор правой части решаемой системы ОДУ
		call fCalculation(f,N,u(j,:),(t(j + 1) + t(j))/2,x,epsilon,u_left,u_right)
		
		call TridiagonalMatrixAlgorithm(w,N,a,b,c,f)
		
		u(j + 1,1:N-1) = u(j,1:N-1) + (t(j + 1) - t(j))*real(w)
		
		! Учитываем левое и правое граничные условия
		u(j + 1,0) = u_left
		u(j + 1,N) = u_right
		
		print*, 't =', t(j+1)       
    
	enddo
	
	! Сохраняем результаты расчётов в файл
	open(1,file = 'Results.dat')
		write(1,*) N
		write(1,*) M
		write(1,*) x_left
		write(1,*) x_right
		write(1,*) T_calc
	    do j = 0,M
			do i = 0,N
				write(1,*) u(j,i)
			enddo
		enddo
	close(1)

end

subroutine DiagonalsPreparation(a,b,c,N,u,t,tau,x,epsilon,u_left,u_right,a_11)

	implicit none
	
	real(8) :: epsilon, t, tau, u_left, u_right
	real(8) ::  u(0:N), x(0:N)
	double complex :: a(1:N-1), b(1:N-1), c(1:N-1)
	double complex :: a_11
	integer :: N
	integer :: i
	
	! Подпрограмма, которая подготавливает массивы, которые содержат диагонали матрицы решаемой системы ОДУ
	! Данная матрица имеет вид [E - a_11*tau*f_u(u,t)] и является трёхдиагональной

	! Входными параметрами являются:
	! u - решение системы ОДУ в текущий момент времени (кроме граничных узлов) 
	! t - текущий момент времени
	! tau - текущий шаг по времени
	! x - сетка по пространству (в общем случае неравномерная)
	! epsilon - малый <<сингулярный>> параметр (в данном типе задач)
	! u_left - левое граничное условие в текущий момент времени
	! u_right - правое граничное условие в текущий момент времени
	! a_11 - параметр численной схемы

	! Выходные параметры:
	! a, b и c - соответствующие вектора
	!
	!  [ a(1)  c(1)                           ] 
	!  [ b(2)  a(2)  c(2)                     ] 
	!  [       b(3)  a(3)  c(3)               ] 
	!  [            ...   ...   ...           ] 
	!  [                    ...    ...        ] 
	!  [                        b(N-1) a(N-1) ] 
	
	! Далее все формулы для конечно-разностных аппроксимаций производных
    ! выписаны для случая неравномерной сетки по пространству,
    ! но при желании можете заменить в последующих формулах все разности типа x(i + 1) - x(i) на h,
    ! в результате чего получите формулы, выписанные на занятии
    
    ! Элементы первой и последней строки вычисляем отдельно
    ! учитывая граничные условия
	
	a(1) = 1.d0 - a_11*tau*(((2.d0*epsilon)/(x(2) - x(0)))*(-((1.d0)/(x(2) - x(1))) - ((1.d0)/(x(1) - x(0)))) + ((u(2) - u_left)/(x(2) - x(0))) - 1.d0)
    c(1) = - a_11*tau*(((2.d0*epsilon)/(x(2) - x(0)))*(((1.d0)/(x(2) - x(1)))) + ((u(1))/(x(2) - x(0))))
    do i = 2,(N - 2)
        b(i) = - a_11*tau*(((2.d0*epsilon)/(x(i + 1) - x(i - 1)))*(((1.d0)/(x(i) - x(i - 1)))) - ((u(i))/(x(i + 1) - x(i - 1))))
        a(i) = 1.d0 - a_11*tau*(((2.d0*epsilon)/(x(i + 1) - x(i - 1)))*(-((1.d0)/(x(i + 1) - x(i))) - ((1.d0)/(x(i) - x(i - 1)))) + ((u(i + 1) - u(i - 1))/(x(i + 1) - x(i - 1))) - 1.d0)
        c(i) = - a_11*tau*(((2.d0*epsilon)/(x(i + 1) - x(i - 1)))*(((1.d0)/(x(i + 1) - x(i)))) + ((u(i))/(x(i + 1) - x(i - 1))))
    enddo
    b(N - 1) = - a_11*tau*(((2.d0*epsilon)/(x(N) - x(N - 2)))*(((1.d0)/(x(N - 1) - x(N - 2)))) - ((u(N-1))/(x(N) - x(N - 2))))
    a(N - 1) = 1.d0 - a_11*tau*(((2.d0*epsilon)/(x(N) - x(N - 2)))*(-((1.d0)/(x(N) - x(N - 1))) - ((1.d0)/(x(N - 1) - x(N - 2)))) + ((u_right - u(N-2))/(x(N) - x(N - 2))) - 1.d0)
	
end


subroutine fCalculation(f,N,u,t,x,epsilon,u_left,u_right)

	implicit none
	
	real(8) :: epsilon, t, u_left, u_right
	real(8) :: u(0:N), x(0:N), f(1:N-1)
	integer :: N
	integer :: i
	
	! Функция, которая вычисляет вектор правой части решаемой системы ОДУ

	! Входными параметрами являются:
	! u - решение системы ОДУ в текущий момент времени (кроме граничных узлов) 
	! t - текущий момент времени
	! x - сетка по пространству (в общем случае неравномерная)
	! epsilon - малый "сингулярный" параметр (в данном типе задач)
	! u_left - левое граничное условие в текущий момент времени
	! u_right - правое граничное условие в текущий момент времени

	! Выходные параметры:
	! f - вектор правой части системы ОДУ
	
	! Далее все формулы для конечно-разностных аппроксимаций производных
    ! выписаны для случая неравномерной сетки по пространству,
    ! но при желании можете заменить в последующих формулах все разности типа x(i + 1) - x(i) на h,
    ! в результате чего получите формулы, выписанные на занятии
        
    ! Учитываем левое граничное условие отдельно от общего цикла
    f(1) = ((2.d0*epsilon)/(x(2) - x(0)))*(((u(2) - u(1))/(x(2) - x(1))) - ((u(1) - u_left)/(x(1) - x(0)))) + u(1)*((u(2) - u_left)/(x(2) - x(0))) - u(1)
    do i = 2,(N - 2)
        f(i) = ((2.d0*epsilon)/(x(i + 1) - x(i - 1)))*(((u(i + 1) - u(i))/(x(i + 1) - x(i))) - ((u(i) - u(i - 1))/(x(i) - x(i - 1)))) + u(i)*((u(i + 1) - u(i - 1))/(x(i + 1) - x(i - 1))) - u(i)
    enddo
    ! Учитываем правое граничное условие отдельно от общего цикла
    f(N - 1) = ((2.d0*epsilon)/(x(N) - x(N - 2)))*(((u_right - u(N - 1))/(x(N) - x(N - 1))) - ((u(N - 1) - u(N - 2))/(x(N - 1) - x(N - 2)))) + u(N - 1)*((u_right - u(N - 2))/(x(N) - x(N - 2))) - u(N - 1)
	
end


subroutine TridiagonalMatrixAlgorithm(x,N,a,b,c,d)

	implicit none
	
	real(8) :: d(N-1)
	double complex :: a(N-1), b(N-1), c(N-1), v(N-1), x(N-1) 
	double complex :: w
	integer :: n
	integer :: i,j
	
	! Функция, которая реализует метод прогонки для решения линейной системы A X = B

	! Входные параметры:
	! d - ветор правой части длины n (столбец или строка)
	! a, b, c - вектора длины n, содержащие коэффициенты диагоналей (b(1) и c(n) не используются)
	!
	!  [ a(1)  c(1)                                  ] [  x(1)  ]   [  d(1)  ]
	!  [ b(2)  a(2)  c(2)                            ] [  x(2)  ]   [  d(2)  ]
	!  [       b(3)  a(3)  c(3)                      ] [        ]   [        ]
	!  [            ...   ...   ...                  ] [  ...   ] = [  ...   ]
	!  [                    ...    ...    ...        ] [        ]   [        ]
	!  [                        b(N-2) a(N-2) c(N-2) ] [ x(N-2) ]   [ d(N-2) ]
	!  [                               b(N-1) a(N-1) ] [ x(N-1) ]   [ d(N-1) ]
    
    v = (0.d0,0.d0)
    x = (0.d0,0.d0)
    
    w = a(1)
    x(1) = d(1)/w
    do i = 2,N-1
        v(i - 1) = c(i - 1)/w
        w = a(i) - b(i)*v(i - 1)
        x(i) = (d(i) - b(i)*x(i - 1))/w
    enddo
    do j = N-2,1,-1
        x(j) = x(j) - v(j)*x(j + 1)
    enddo

end