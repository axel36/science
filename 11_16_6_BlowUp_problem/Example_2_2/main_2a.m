clear;
clc;
%Задача отыскание разрушения решения;

%------------------ЗАДАНИЕ НЕОБХОДИМЫХ ПЕРЕМЕННЫХ--------------------------
%global m;
m_pov=3;
%global p;     %Переменные для данной задачи: степени U и длина отрезка
p=3;
global L;
L=5;
%global N; 
N=50;%Число ОТРЕЗКОВ по Х
M=50;% Число ОТРЕЗКОВ по времени
%global h;
h=L/N;%Разбиение по Х 
tt=3;%Время
tau=tt/M;%Изменение времени за итерацию
aa=(1+1i)/2;% переменная Схемы Розенброка

%-----------------ЗАДАНИЕ НЕОБХОДИМЫХ КОНСТАНТ-----------------------------
a=pi/4;             
A=sin(3*a)^5+((-5)*m_pov*a*cos(3*a)*(sin(3*a)^4))^(1/(p-m_pov+1));
M_0=M;
N_0=N;

%------------------------------СГУЩЕНИЕ------------------------------------
r_x=2; %ПАРАМЕТР СГУЩЕНИЯ
r_t=2;

S=8; %КОЛИЧЕСТВО СГУЩЕНИЙ
var_x=1; %
var_t=1; %
%----------------------------САМА ПРОГРАММА--------------------------------

u=zeros(M_0,N_0,S);

for s=1:1:S
      %вывод
   Mat=ones(1,N);%ИЗМЕНЕНИЕ МАТРИЦЫ ДЛЯ СХЕМЫ РОЗЕНБРОКА
    Mat(N)=0;
    tau=tt/M;%Изменение времени за итерацию
    h=L/N;%Разбиение по Х 
    n=0;%счетчик
    U = zeros(1,N+1);%обнуляем вектор с решениями
    X = zeros(1,N+1);
    %Цикл Для получения начального приближения
    for k=0:h:L
   
        n=n+1;
        X(n)=k;%Вектор Х координаты
        if k<2
            %U(1,n)=A;                  %ДЛЯ ВТОРОГО ПРИМЕРА
            U(1,n)=A;  
        else
            U(1,n)=A-(sin(a*(k-1))^5);%начальное приближение
        end
    end
%Сохраняем базовую сетку по Х
    if s==1
         X_0 = X;
    end
%plot(X,U(1,:),'-*r','MarkerSize',3,'LineWidth',1);
n=0;%переменная цикла счетчик
t=zeros(1,tt/tau);
 for k=0:tau:tt
     n=n+1;
     t(n)=k;
 end
% Сохраняем базовую сетку по Т
 if s==1
    T_0=t;
 end
    
    
    %-----------Помощь для отбора конечной сетки N_0 X M_0-----------------
    n=0;%счетчик
    I=zeros(1,N+1);
    J=zeros(1,M+1);
   for i = 1:var_x:N+1  % отбоР по Х
        n=n+1;
        I(n)=i;
   end
   n=0;%счетчик
   for j = 1:var_t:M+1  % отбоР по Х
        n=n+1;
        J(n)=j;
   end
 %-------------------------------------------------------------------------
 %
 %
 for k = 1:(N_0 + 1) 
            u(1,k,s) = U(I(k)); 
 end 
 i=2;
%-----------------------------Сама Схема-----------------------------------
 for n= 1:M  
        s
        n
        M
        
     %Y=Yak(U(2:N+1));%Считаем матрицу Якоби
     F=Fuu(U(2:N+1),N,m_pov,p,h);%Считаем вектор значений функции 
%      F=F';
%     w=TridiagonalMatrixAlgorithm(Mat-aa*tau*Y,F);%w=A^(-1)*F
     


%      AA=Mat-aa*tau*Y;
%      coeff=AA(N-1,N-2)/AA(N,N-2);
%      AA(N,N-2)=0;   
%      AA(N,N-1)=AA(N-1,N-1)-coeff*AA(N,N-1);
%      AA(N,N)=AA(N-1,N)-coeff*AA(N,N);
     
        [a_w b_w c_w coeff]=Prepares_beforeNew_tridalgorithm(U(2:N+1),aa,tau,Mat,N,m_pov,p,h);

       F(N)=F(N-1)-coeff*F(N);
     
     
     
     w=TridiagonalMatrixAlgorithm(a_w, b_w, c_w,F);
%       ww=TridiagonalMatrixAlgorithm(a_w, b_w, c_w,F);
%       if (sum(w)~= sum(ww))
%           break
%       end
%     w=A^(-1)*F;
     w=real(w);
     w=w';%считаем w
      
     
     
     U(2:N+1)=U(2:N+1)+tau*w;%Записываем новые значения в U
     U(1) = ((4*U(2)^m_pov-U(3)^m_pov)/3)^(1/m_pov) ;
     
     % plot(X,U,'-*r','MarkerSize',3,'LineWidth',1);
     
     if n+1 == J(i)
         
        for k = 1:(N_0 + 1) 
            u(i,k,s) = U(I(k)); 
        end 
        
        i=i+1;
     end
     
     
%     U(n+1,N+1) =6-2*sin(4*3.14159265359*t(n)); %не нужно в этой программе
  %  TT(n+1,s)=t(n+1); %Для отладки
    
 end
  %graf;
%------------------------------конец схемы---------------------------------
%  %Начало отбора
%    n=0;%счетчик
%    for i = 1:var_x:N+1  % отбоР по Х
%         n=n+1;
%         k=0;
%         for j =1:var_t:M+1 % Отбор по времени
%             k=k+1;
%             u(k,n,s)=U(j,i);
%             TTT(k,s)=TT(j,s); %проверочная матрица времени
%         end
%     end
%       
    var_x=var_x*r_x; %приращение для следующей итерации
     var_t=var_t*r_t;
%     K(m)=n;
    N=N*r_x; %Cгущение сеток Х и времени
    M=M*r_t;
end
    
save('10_Ex_2a');
TemplateForBlowUpDiagnostics;
