clear;
aa=(1+1i)/2;%Перем Схемы
e=10^-2;%малый парам
 E=eye(2);%Матрица в схеме
 s=12;%Число сгущений
 uu0=3;%Нач. Условия U
 uu1=-1;%Нач. Условия Х   
 dl=0.01;%Начальное dL
 n=1; %Счетчик цикла 
 
 %Первый цикл, набираем несгущ. сетку
 while uu1 < 2    
    U(1,n)=uu0;%Сам набор
    F=[((2/e)*uu0*(uu1 - uu0))/sqrt(1 + (4/e^2)*uu0^2*(uu1 - uu0)^2); 1/sqrt(1 + (4/e^2)*uu0^2*(uu1 - uu0)^2)];
    Yak=[f_1_0(uu0,uu1,e) f_1_1(uu0,uu1,e);f_2_0(uu0,uu1,e) f_2_1(uu0,uu1,e)];
    A=E-dl*aa*Yak;
    w=inv(A)*F; 
    W=real(w);         %Схема , Автономизированная методом длины дуги
    uu0=uu0+dl*W(1);
    uu1=uu1+dl*W(2);
    n=n+1; 
 end
  X(1)=n;%Набираем вектор Х для графика R(N)
  a=1;%Переменная сгущения
  
for m = 1:1:s
    m%вывод  
    z=1;%Переменная для отбора сгущ сеток
    a=a*2;%Увеличение перем. для сгущ.
    dl=0.01/a;%Уменьшение dL
    n=n*2;%Увеличиваем 
    uu0=3;%Нач значения U
    uu1=-1;%Нач значение l
    %Цикл отбора сгущ. сеток
    for t= 1:1:n
         if rem(t,a)== 1 %остаток от делен на сгущенность =1(Отбираем на сгущенных сетках нужные значения)
            U(m+1,z)=uu0;% заполняем матрицу значений  
            N(m,z)=t;%проверка
          	z=z+1;%счетчик для сгущ значений
         end
        UUU(m,t)=uu0; 
        F=[((2/e)*uu0*(uu1 - uu0))/sqrt(1 + (4/e^2)*uu0^2*(uu1 - uu0)^2); 1/sqrt(1 + (4/e^2)*uu0^2*(uu1 - uu0)^2)];
        Yak=[f_1_0(uu0,uu1,e) f_1_1(uu0,uu1,e);f_2_0(uu0,uu1,e) f_2_1(uu0,uu1,e)];
        A=E-dl*aa*Yak;
        w=inv(A)*F;       %Сама схема
        W=real(w);
        uu0=uu0+dl*W(1);
        uu1=uu1+dl*W(2);   
    end
 end
r=2;%Переменная сгущения
ff=1;%Индекс в матрице значений р
pp=1;%Начальный порядок точности
v=1;%индекс в матице R, отвечающий за 3-х мерность(или переход к новому столбцу)
    
%цикл для Вычисления U с волной и R   1 Этап ( 1-й столбец)
 for k= ff:1:s-1
    R(k,:)=(U(k+1,:)-U(k,:))/(r^pp-1);%вычисляем R
    Uu(k,:)=U(k+1,:)+R(k,:);%Вычисляем вектор уточненных значений
    dD(k)=sqrt(sum(R(k,:).*R(k,:)))/sqrt(sum(Uu(k,:).*Uu(k,:)))*100;%Относительная погрешность
    Y(1,k)=sqrt(sum(R(k,:).*R(k,:)));%значения для построения графика ( норма вектора ошибки)
 end
       %Цикл для Pэфф   1 Этап                                                    
 for k=ff:1:s-2
     h=sqrt(sum(R(k+1,:).*R(k+1,:)))/sqrt(sum(R(k,:).*R(k,:)));%отношение Rn и Rn+1
     p(k,1)=log(h)/log(r)*(-1);     %Соответственно само р                                     
     
 end
 
 % второй этап для Pэфф , U, R (остальные столбцы)
 
  while ff<s-1
     v=v+1;
    ff=ff+1;
    pp=pp+1;%увеличение точности при каждой итерации
     
    for k= ff:1:s-1
        R(k,:,v)= (Uu(k+1-ff+1,:,v-1)-Uu(k-ff+1,:,v-1))/(r^pp-1);%вычисляем R
        Uu(k,:,v)=Uu(k-ff+2,:,v-1)+R(k,:,v);%Вычисляем вектор уточненных значений
        dD(k,v)=sqrt(sum(R(k,:,v).*R(k,:,v)))/sqrt(sum(Uu(k,:,v).*Uu(k,:,v)))*100;%Относительная погрешность
        Y(v,k)=sqrt(sum(R(k,:,v).*R(k,:,v)));%значения для построения графика ( норма вектора R)
    end
    
    for k=ff:1:s-2
         h=sqrt(sum(R(k+1,:,v).*R(k+1,:,v)))/sqrt(sum(R(k,:,v).*R(k,:,v)));
         p(k,v)=log(h)/log(r)*(-1);      %остальные столбцы с р                                  
    end
   
  end
%  
%    for k= 1:1:s-1
%    
%     
% t=rem(k,2)+1;% для смены цветов
% 
% 
%  VarX=X(k+1:s);
%  VarY=Y(k,k:s-1);1
%  loglog(VarX,VarY) ;%график
% 
%  hold on  %длал на разных
%  end


 p
%  dD