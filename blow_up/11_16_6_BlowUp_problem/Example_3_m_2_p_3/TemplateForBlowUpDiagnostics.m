% clear;
% clc;
% 
% load('data.mat');

% u_array - массив размерности SxSx(M_0+1)x(N_0+1), содержащий решение PDE на разных сетках в узлах, совпадающих с узлами базовой сетки;
% первый параметр - число сгущающихся сеток S, на которых вычислялось решение;
% второй парамет - нужен для хранения рекуррентно уточнённых решений, включая исходное;
% третий параметр - число узлов M_0+1 базовой сетки по t; 
% четвёртый параметр - число узлов N_0+1 базовой сетки по x.

% Т.е. если на каждой сетке вычислено решение u (вектор размерности (M_0+1)x(N_0+1))
% и он содержит только сеточные значения функции u в узлах совпадающих с узлами базовой сетки,
% то массив u_array может быть заполнен следующим образом: 

% u_array = zeros(S,S,M_0 + 1,N_0 + 1); 
% % Большой Цикл (пересчитывает решение S раз на разных сетках)
% % Вектор решения выдаётся только в узлах, совпадающих с узлами исходной сетки
% for s = 1:S 
%     % Вызываем функцию которая вычисляет решение заданного PDE на сетке с номером s
%     u = % Функция, которая вычисляет решение заданного PDE на сетке с номером s
%     for m = 1:(M_0+1)
%         for n = 1:(N_0+1)
%             u_array(s,1,m,n) = u(m,n);
%         end
%     end
% end

% % -------------------------------------------------------------------------
% % ВНИМАНИЕ! Далее перечисляются параметры, которые надо дополнительно задать
% 
% % Задаём параметры рекуррентного уточнения решения по Ричадсону
% p = 2; % Теоретический порядок точности схемы
% q = 1;
% r = 2; % Коэффициент сгущения сетки
% 
% %t_0 = % Базовая сентка по времени - массив размерности 1x(M_0+1)
% %x_0 = % Базовая сентка по координате - массив размерности 1x(N_0+1)
% 
% % ----------------------ТО, ЧТО ДОБАВИЛ Я САМ----------------------------
u_array = zeros(S,S,M_0 + 1,N_0 + 1); 
t_0 = T_0;
x_0 = X_0;
p = 2; % Теоретический порядок точности схемы
q = 1;
r = 2; % Коэффициент сгущения сетки
for s = 1:S 
    % Вызываем функцию которая вычисляет решение заданного PDE на сетке с номером s
    %u = % Функция, которая вычисляет решение заданного PDE на сетке с номером s
    for m = 1:(M_0+1)
        for n = 1:(N_0+1)
            u_array(s,1,m,n) = u(m,n,s);
        end
    end
end
%--------------------------------------------------------------------------
% Рекурентно уточняем решение по Ричардсону
for l = 2:S
    for s = l:S
        for i = 1:(M_0 + 1)
            for j = 1:(N_0 + 1)
                u_array(s,l,i,j) = u_array(s,l-1,i,j) + (u_array(s,l-1,i,j) - u_array(s-1,l-1,i,j))/(r^(p + q*((l - 1) - 1)) - 1);
            end
        end
    end
end

% Вычисляем эффективный порядок точности вычисления решения на каждом временном слое
% m >= 2 (кроме первого, так как на нём решение задано точно)
figure;
p_eff_ForEveryLayer = zeros(S-2,M_0);
for m = 2:(M_0 + 1)
    for s = 3:S
        R_rN = sqrt(sum((u_array(s,2,m,:)-u_array(s,1,m,:)).^2));
        R_N = sqrt(sum((u_array(s-1,2,m,:)-u_array(s-1,1,m,:)).^2));
        p_eff_ForEveryLayer(s-2,m - 1)= ((log(R_N))-(log(R_rN)))/(log(r));
    end
end
% Рисуем зависимость теоретического порядка точности от номера узла
plot(t_0(2:M_0+1),t_0(2:M_0+1)*0 + p,'-*k','MarkerSize',3);
hold on;
% Рисуем зависимость эффективного порядка точности от номера узла
plot(t_0(2:M_0+1),p_eff_ForEveryLayer(S-2,:),'-sk','MarkerSize',5,'LineWidth',1);
hold off;
xlabel('t');
ylabel('p^{eff}');
title('p^{eff} for each time layer');
axis([t_0(2) t_0(length(t_0)) -2 (p+2)]);

%continue

% Вычисляем эффективный порядок точности (во всех пространственных точках кроме граничных) 
% Вычисляем решение на определённом временном слое с номером m
p_eff_ForParticularLayer = zeros(S-2,N_0 - 1);
 m = 8; % Номер соответствующего временного слоя
%m = length(t_0); % Номер последнего временного слоя
for n = 2:N_0
    for s = 3:S
        R_rN = sqrt((u_array(s,2,m,n)-u_array(s,1,m,n)).^2);
        R_N = sqrt((u_array(s-1,2,m,n)-u_array(s-1,1,m,n)).^2);
        p_eff_ForParticularLayer(s-2,n - 1)= ((log(R_N))-(log(R_rN)))/(log(r));
    end
end
figure;
% Рисуем зависимость теоретического порядка точности от номера узла
plot(x_0(2:N_0),x_0(2:N_0)*0 + p,'-*k','MarkerSize',3);
hold on;
% Рисуем зависимость эффективного порядка точности от номера узла
plot(x_0(2:N_0),p_eff_ForParticularLayer(S-2,:),'-sk','MarkerSize',5,'LineWidth',1);
hold off;
xlabel('x');
ylabel('p^{eff}');
title('p^{eff} for particular time layer');
axis([x_0(2) x_0(length(x_0)-1) -2 (p+2)]);

% Проверяем корректную реализацию схемы (выводим эффективные порядки точности)
p_total = zeros(S-2,S-2);
for l = 3:S
    for s = l:S
        R_rN = sqrt(sum(sum((u_array(s,l-1,:,:)-u_array(s,l-2,:,:)).^2)));
        R_N = sqrt(sum(sum((u_array(s-1,l-1,:,:)-u_array(s-1,l-2,:,:)).^2)));
        p_total(s-2,l-2)= ((log(R_N))-(log(R_rN)))/(log(r));
    end
end
p_total

% Проверяем корректную реализацию схемы (выводим эффективные порядки точности для конкретного узла двумерной сетки)
m = 25;
n = 25;
p_part_1 = zeros(S-2,S-2);
for l = 3:S
    for s = l:S
        R_rN = sqrt((u_array(s,l-1,m,n)-u_array(s,l-2,m,n)).^2);
        R_N = sqrt((u_array(s-1,l-1,m,n)-u_array(s-1,l-2,m,n)).^2);
        p_part_1(s-2,l-2)= ((log(R_N))-(log(R_rN)))/(log(r));
    end
end
p_part_1

% Проверяем корректную реализацию схемы (выводим эффективные порядки точности для всех узлов кроме момента разрушения)
number = 25;
p_part_2 = zeros(S-2,S-2);
for l = 3:S
    for s = l:S
        R_rN = sqrt(sum(sum((u_array(s,l-1,1:number,:)-u_array(s,l-2,1:number,:)).^2)));
        R_N = sqrt(sum(sum((u_array(s-1,l-1,1:number,:)-u_array(s-1,l-2,1:number,:)).^2)));
        p_part_2(s-2,l-2)= ((log(R_N))-(log(R_rN)))/(log(r));
    end
end
p_part_2

% % Рисуем в двойном логарифмическом масштабе графики зависимостей ошибок от
% % числа сеток
% figure;
% clear delta;
% clear N_mesh;
% delta = zeros(S-1,S-1);
% N_mesh = zeros(S-1,S-1);
% 
% for l = 1:S-1
%     
%     for s = l:S-1
%         delta(s - l + 1,l) = sqrt(sum(sum((u_array(s+1,l,:,:)-u_array(s,l,:,:)).^2)));
%         N_mesh(s - l + 1,l) = M_0*(r^(s))*N_0*(r^(s));
%     end
%     loglog(N_mesh(:,l),delta(:,l));
%     hold on;
% end
% axis([M_0*(r^1)*N_0*(r^1) M_0*(r^(S-1))*N_0*(r^(S-1)) 0 delta(1,1)]);

% Конструируем динамическую картинку, на которой на каждом кадре
% отображается зависимость эффективного порядка точности от номер узла
% для временного слоя, соответствующего этому кадру

%continue;

figure;

k = 1; % В видео записывается каждый k-ый кадр
for m = 1:k:M_0+1
    
    % Вычисляем эффективный порядок точности (во всех пространственных точках кроме граничных) 
    % на определённом временном слое с номером m
    p_eff_ForParticularLayer = zeros(S-2,N_0 - 1);
    for n = 2:N_0
        for s = 3:S
            R_rN = sqrt((u_array(s,2,m,n)-u_array(s,1,m,n)).^2);
            R_N = sqrt((u_array(s-1,2,m,n)-u_array(s-1,1,m,n)).^2);
            p_eff_ForParticularLayer(s-2,n - 1)= ((log(R_N))-(log(R_rN)))/(log(r));
        end
    end
    % Рисуем зависимость теоретического порядка точности от номера узла
    plot(x_0(2:N_0),x_0(2:N_0)*0 + p,'-*k','MarkerSize',3);
    hold on;
    % Рисуем зависимость эффективного порядка точности от номера узла
    plot(x_0(2:N_0),p_eff_ForParticularLayer(S-2,:),'-sk','MarkerSize',5,'LineWidth',1);
    hold off;
    xlabel('x');
    ylabel('p^{eff}');
    title('p^{eff} for particular time layer');
    axis([x_0(2) x_0(length(x_0)-1) -2 (p+3)]);
    txt2=num2str(m);
    txt1='layer number =';
     txt=[txt1 ' ' txt2] ;
     hT = text(1, 3,txt); 
     
    drawnow;
    pause(0.05);
    
    m
    
    % Сохраняем динамическую картинку в файл, 
    % который может быть преобразован в видео
    mov((m-1)/k+1) = getframe;
    
end

% Сохраняем видеофайл с презентацией результатов вычислений
%movie2avi(mov, 'p_eff1.avi', 'compression', 'None');

